<script>
  (function initUIThreeManager() {
    const g = typeof window !== 'undefined' ? window : globalThis;
    function isDebug() {
      try {
        if (g.UIThreeDebug) return true;
        if (g.localStorage && g.localStorage.getItem) {
          return g.localStorage.getItem('UIThreeDebug') === '1';
        }
      } catch {}
      return false;
    }

    function debugLog() {
      if (!isDebug() || !g.console || !g.console.debug) return;
      try { g.console.debug.apply(g.console, arguments); } catch {}
    }

    function detectIOS() {
      try {
        const ua = (g.navigator && g.navigator.userAgent) || '';
        const isIOSUA = /iPad|iPhone|iPod/.test(ua);
        const isTouchMac = ua.includes('Macintosh') && g.document && 'ontouchend' in g.document;
        return isIOSUA || isTouchMac;
      } catch {}
      return false;
    }

    function disposeRenderer(renderer) {
      if (!renderer) return;
      // Avoid forcing context loss; let the browser manage contexts for stability
      try { if (renderer.dispose) renderer.dispose(); } catch {}
    }

    const state = {
      isIOS: null,
      previewRenderer: null,
      previewOwner: null,
      previewCanvas: null,
      previewOpts: null,
      previewContextLost: false,
      previewCanvasListeners: null
    };

    function detachPreviewCanvasListeners() {
      if (!state.previewCanvas || !state.previewCanvasListeners) return;
      const listeners = state.previewCanvasListeners;
      try { if (listeners.lost) state.previewCanvas.removeEventListener('webglcontextlost', listeners.lost); } catch {}
      try { if (listeners.restored) state.previewCanvas.removeEventListener('webglcontextrestored', listeners.restored); } catch {}
      state.previewCanvasListeners = null;
    }

    function disposeThreeObject(root) {
      if (!root) return;
      try {
        const disposedGeometries = new Set();
        const disposedMaterials = new Set();
        const disposedTextures = new Set();
        root.traverse((node) => {
          if (!node) return;
          if (node.geometry && typeof node.geometry.dispose === 'function') {
            try {
              const id = node.geometry.uuid || node.geometry.type;
              if (!disposedGeometries.has(id)) {
                node.geometry.dispose();
                disposedGeometries.add(id);
                debugLog('[UIThree] Disposed geometry', id);
              }
            } catch {}
          }
          if (node.material) {
            const materials = Array.isArray(node.material) ? node.material : [node.material];
            materials.forEach((material) => {
              if (!material) return;
              try {
                Object.values(material).forEach((value) => {
                  if (value && (value.isTexture || value.isRenderTarget) && typeof value.dispose === 'function') {
                    try {
                      const texId = value.uuid || value.name || 'texture';
                      if (!disposedTextures.has(texId)) {
                        value.dispose();
                        disposedTextures.add(texId);
                        debugLog('[UIThree] Disposed texture', texId);
                      }
                    } catch {}
                  }
                });
                if (typeof material.dispose === 'function') {
                  try {
                    const matId = material.uuid || material.name || material.type;
                    if (!disposedMaterials.has(matId)) {
                      material.dispose();
                      disposedMaterials.add(matId);
                      debugLog('[UIThree] Disposed material', matId);
                    }
                  } catch {}
                }
              } catch {}
            });
          }
        });
        debugLog('[UIThree] Disposed object', root.uuid || root.name || root.type || 'Object3D');
      } catch {}
    }

    function resetPreviewState(preserveContextLost) {
      detachPreviewCanvasListeners();
      if (state.previewRenderer) {
        debugLog('[UIThree] Released preview renderer for owner', state.previewOwner || 'unknown');
      }
      state.previewRenderer = null;
      state.previewOwner = null;
      state.previewCanvas = null;
      state.previewOpts = null;
      if (!preserveContextLost) {
        state.previewContextLost = false;
      }
    }

    function applyRendererOptions(renderer, opts, THREE, isIOS) {
      if (!renderer) return;
      const enableShadows = !!(opts && opts.enableShadows);
      try {
        renderer.shadowMap.enabled = enableShadows;
        if (enableShadows && THREE) {
          const shadowType = isIOS ? (THREE.PCFShadowMap || renderer.shadowMap.type) : (THREE.PCFSoftShadowMap || renderer.shadowMap.type);
          if (shadowType != null) {
            renderer.shadowMap.type = shadowType;
          }
        }
      } catch {}
      try {
        const clearAlpha = opts && opts.alpha ? 0 : 1;
        renderer.setClearColor(0x000000, clearAlpha);
      } catch {}
    }

    function getPreviewRenderer(owner, canvas, opts) {
      const THREE = g.hytopia && g.hytopia.three;
      if (!THREE || !canvas) return null;

      // Ensure only one preview renderer exists at a time
      if (state.previewRenderer && state.previewOwner && state.previewOwner !== owner) {
        debugLog('[UIThree] Reassigning preview owner from', state.previewOwner, 'to', owner);
        disposeRenderer(state.previewRenderer);
        resetPreviewState();
      }

      // If canvas changed, recreate renderer (WebGLRenderer cannot rebind canvases)
      if (state.previewRenderer && state.previewCanvas !== canvas) {
        debugLog('[UIThree] Canvas changed for owner', owner, '- recreating renderer');
        disposeRenderer(state.previewRenderer);
        resetPreviewState();
      }

      // Recreate if context is lost
      try {
        if (state.previewRenderer) {
          const gl = state.previewRenderer.getContext && state.previewRenderer.getContext();
          if (gl && typeof gl.isContextLost === 'function' && gl.isContextLost()) {
            debugLog('[UIThree] Detected lost WebGL context - recreating renderer');
            disposeRenderer(state.previewRenderer);
            state.previewContextLost = true;
            resetPreviewState(true);
          }
        }
      } catch {}

      if (!state.previewRenderer) {
        const isIOS = state.isIOS ?? (state.isIOS = detectIOS());
        const params = {
          canvas,
          alpha: !!(opts && opts.alpha),
          antialias: isIOS ? false : !!(opts && (opts.antialias ?? true)),
          stencil: false,
          premultipliedAlpha: false,
          preserveDrawingBuffer: false,
          depth: true
        };
        const optPowerPref = opts && typeof opts.powerPreference === 'string' ? opts.powerPreference : null;
        if (optPowerPref) {
          params.powerPreference = optPowerPref;
        }

        const renderer = new THREE.WebGLRenderer(params);
        const dpr = isIOS ? 1 : Math.min(g.devicePixelRatio || 1, 2);
        try { renderer.setPixelRatio(dpr); } catch {}
        try {
          const rect = (canvas.parentElement && canvas.parentElement.getBoundingClientRect) ? canvas.parentElement.getBoundingClientRect() : { width: g.innerWidth, height: g.innerHeight };
          renderer.setSize(rect.width || g.innerWidth, rect.height || g.innerHeight, false);
        } catch {}
        applyRendererOptions(renderer, opts, THREE, isIOS);

        try {
          const lostHandler = (e) => {
            debugLog('[UIThree] webglcontextlost for owner', owner);
            try { if (e && e.preventDefault) e.preventDefault(); } catch {}
            state.previewContextLost = true;
          };
          const restoredHandler = () => {
            debugLog('[UIThree] webglcontextrestored for owner', owner);
            state.previewContextLost = false;
            // Recreate renderer on restore to ensure a healthy context
            try {
              disposeRenderer(state.previewRenderer);
            } catch {}
            resetPreviewState();
          };
          canvas.addEventListener('webglcontextlost', lostHandler);
          canvas.addEventListener('webglcontextrestored', restoredHandler);
          state.previewCanvasListeners = { lost: lostHandler, restored: restoredHandler };
        } catch {}

        state.previewRenderer = renderer;
        state.previewOwner = owner || 'preview';
        state.previewCanvas = canvas;
        state.previewContextLost = false;
        debugLog('[UIThree] Created preview renderer for owner', state.previewOwner);
      } else {
        state.previewOwner = owner || state.previewOwner;
        try {
          const rect = (canvas.parentElement && canvas.parentElement.getBoundingClientRect) ? canvas.parentElement.getBoundingClientRect() : { width: g.innerWidth, height: g.innerHeight };
          const dpr = state.isIOS ? 1 : Math.min(g.devicePixelRatio || 1, 2);
          state.previewRenderer.setPixelRatio(dpr);
          state.previewRenderer.setSize(rect.width || g.innerWidth, rect.height || g.innerHeight, false);
        } catch {}
      }

      state.previewCanvas = canvas;
      state.previewOpts = opts ? Object.assign({}, opts) : {};
      applyRendererOptions(state.previewRenderer, state.previewOpts, THREE, state.isIOS);

      return state.previewRenderer;
    }

    function releasePreviewRenderer(owner) {
      if (!state.previewRenderer) return;
      if (owner && state.previewOwner && state.previewOwner !== owner) return;
      disposeRenderer(state.previewRenderer);
      resetPreviewState();
    }

    g.UIThree = g.UIThree || {
      getPreviewRenderer,
      releasePreviewRenderer,
      disposeObject: disposeThreeObject,
      getPreviewOwner: function() { return state.previewOwner; },
      getPreviewStatus: function() {
        var ctx = null, lost = false;
        try { ctx = state.previewRenderer && state.previewRenderer.getContext && state.previewRenderer.getContext(); } catch {}
        try { if (ctx && typeof ctx.isContextLost === 'function') lost = ctx.isContextLost(); } catch {}
        return { owner: state.previewOwner, hasRenderer: !!state.previewRenderer, hasCanvas: !!state.previewCanvas, contextLost: !!(state.previewContextLost || lost) };
      }
    };
  })();
</script>
